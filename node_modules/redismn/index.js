import ioRedis from "ioredis";
import * as fs from "node:fs";
import {json} from "express";

export default class redis_exp{
    constructor(url,port){
     this.client=new ioRedis({
         host:url,
         port:port
     })



}
async start(){
        console.log("pinging redis"+":"+await this.client.ping());
}

async jsonset(key,jsonobj,model_name,ttl){
        if (key ===undefined ||jsonobj===undefined||model_name===undefined){
            throw new Error("parameter in jsonset in not present");
        }
            await this.client.call("JSON.SET",model_name+":"+key,"$",JSON.stringify(jsonobj));
        if (ttl!=undefined){
            await this.client.expire(model_name+":"+key,ttl);
        }


}
async jsongetAll(key,model_name){
    if (key ===undefined ||model_name===undefined){
        throw new Error("parameter in jsongetAll in not present");
    }
        let jsonobj=await this.client.call("JSON.GET", model_name+":"+key,"$");
    try {
        return await JSON.parse(jsonobj)[0];
    }catch{
        return undefined;
    }

}
async jsonget(key,pathinput,model_name){
    if (key ===undefined ||pathinput===undefined||model_name===undefined){
        throw new Error("parameter in jsonget in not present");
    }
      let jsonobj=  await this.client.call("JSON.GET",model_name+":"+key,`$.${pathinput}`);
    try {
        return await JSON.parse(jsonobj)[0];
    }catch{
        return undefined;
    }
}
async jsonqueryText(val,model_name,preprocessor_optional){
    if (val===undefined||model_name===undefined){
        throw new Error("parameter in jsonqueryText in not present");
    }
       const result= await this.client.call("FT.SEARCH",model_name,val);
    let resultarr = [];
   if (preprocessor_optional) {
        preprocessor_optional(result,resultarr);
    }else{

       for (let i = 1; i < result.length - 1; i += 2) {
           resultarr.push([result[i], JSON.parse(result[i + 1][1])])
       }
   }
       return resultarr;

}
jsonqueryTextavailible(){
        return {
            "simpletext":"searchfor field where this is availble with property text",
            "*":"search for all availble document in current model/index",
            "simple phrase ":"(double inverted comman must)exact match",
            "texta |textb":"one of texta and textb is availble",
             "texta +textb":"both of texta and textb is availble",
            "@key:value":"key value pair",
            "%valuue%":"use for ignore typos",
            "@key:[lowerbound upperbound]":"use for range search for numeric values ",

        }
}

    async jsonquery(key ,val,model_name,preprocessor_optional){
        if (key===undefined||val===undefined||model_name===undefined){
            throw new Error("parameter in jsonquery in not present");
        }
        let result;
        if (Number.isInteger(val)){
            result= await this.client.call("FT.SEARCH",model_name,`@${key}:[${val} ${val}]`);
        }else{
            result= await this.client.call("FT.SEARCH",model_name,`@${key}:${val}`);
        }

        let resultarr=[];
        ;
        if (preprocessor_optional) {
            preprocessor_optional(result,resultarr);
        }else{

            for (let i = 1; i < result.length - 1; i += 2) {
                resultarr.push([result[i], JSON.parse(result[i + 1][1])])
            }
        }
        return resultarr;

    }
async jsonSchemaIdx(model_name,key_tag_arr){
//    [ {key_name:value,
//         tag_type:value,
//              arr_type:value();same as tag type only use when array tag is used
//     sortable:true/false optional
//    }
//     ]
//     availble tags=["TEXT","NUMERIC,"ARRAY","TAG",EXtras]
    let indexes=await this.client.call("FT._LIST");
    const exists = indexes.includes(model_name);
    if (exists){
        console.log("schema already exists",model_name);
        return
    }
    let create=[model_name,"ON","JSON","PREFIX",1,model_name+":","SCHEMA"]
    key_tag_arr.forEach((pair)=>{
        if (!pair.tag_type || !pair.key_name ){
            throw new Error("missing tag_type or key_name")
        }
        if(pair.tag_type=="ARRAY"){
            if (pair.arr_type!=undefined){
                create.push(`$.${pair.key_name}[*]`,"AS",pair.key_name,pair.arr_type)   //$.first_name","AS","first_name","TEXT"

            }else{
                create.push(`$.${pair.key_name}`,"AS",pair.key_name,"TAG");

                }
            }

        else{
            create.push(`$.${pair.key_name}`,"AS",pair.key_name,pair.tag_type);
        if (pair.sortable!==undefined || pair.sortable){
            create.push("SORTABLE");
        }}  `4`
    }
    );
    this.client.call("FT.CREATE",...create);
}

 where(model_name,ttl){
        if(ttl===undefined){
            return new this.#queryconstructor(this.client,model_name,120);
        }else{
     return new this.#queryconstructor(this.client,model_name,ttl);}
}
whereagregater(model_name){
       return new this.#advancequeries(this.client,model_name);
}
#advancequeries=class{
  constructor(client,model_name){
      this.searcharr=["FT.AGGREGATE",model_name, "*" ];
      this.model_name=model_name;
      this.client=client;
      // this.limitarr=[];
  }
  jsonnumrange(key, min, max, ){
    this.searcharr.push( "FILTER", "@"+key,  min,  max);
    return this;
  }
  jsongte(key, value){
      this.searcharr.push("FILTER", `@${key} >= ${value}`);
      return this;
  }
  jsonlte(key, value){
      this.searcharr.push("FILTER", `@${key} <= ${value}`);
      return this;
  }
  jsongt(key, value){
      this.searcharr.push("FILTER", `@${key} > ${value}`);
      return this;
  }
  jsonload(key){
     this.searcharr.push("LOAD",1,"@"+key);
     return this;
  }
  jsonlt(key, value){
      this.searcharr.push("FILTER", `@${key} < ${value}`);
      return this;
  }
  jsonskiplimit(offset,number){
      this.searcharr.push("LIMIT",offset, number);
      return this;
  }
jsonsort(key,order){
      this.searcharr.push("SORTBY", "@"+key,  order);
      return this;
}
jsongroup(key){
      this.searcharr.push("GROUPBY", "1", "@"+key);
      return this;
}
jsonaccumulator(key, MAX_MIN_AVG_SUM_PUSH){

    this.searcharr.push("REDUCE", MAX_MIN_AVG_SUM_PUSH, 1, "@" + key, "AS", MAX_MIN_AVG_SUM_PUSH + "_" + key);

      return this;

}


 async exec(){

      let result =await this.client.call(...this.searcharr);
      this.searcharr=["FT.AGGREGATE",this.model_name];
      return (result);

  }
}
     hsetredis=class{
    constructor(redis_client){
        this.client=redis_client;
    }
    async hsetSchemaIdx(model_nameorcustom,key_tag_arr){
//    [ {key_name:value,
//         tag_type:value,
//              arr_type:value()same as tag type only us ewhen array tag is used
//    }
//     ]
//     availble tags=["TEXT","NUMERIC,"ARRAY","TAG",EXtras]
//         availlble "HASH",
        let create=[model_nameorcustom,"ON","HASH","PREFIX",1,model_nameorcustom+":","SCHEMA"]
        key_tag_arr.forEach((pair)=>{
            if (!pair.tag_type || !pair.key_name ){
                throw new Error("missing tag_type or key_name")
            }
            if(pair.tag_type=="ARRAY"){
                if (pair.arr_type!=undefined){
                    create.push(`$.${pair.key_name}[*]`,"AS",pair.key_name,pair.arr_type)   //$.first_name","AS","first_name","TEXT"

                }else{
                    create.push(`$.${pair.key_name}`,"AS",pair.key_name,"TAG");
                }

            }else{
                create.push(`$.${pair.key_name}`,"AS",pair.key_name,pair.tag_type);
            }
        });
        this.client.call("FT.CREATE",...create);
    }
    async  hsetset(key,val$jsonobj,model_nameorcustom,ttl){
        await this.client.hset(`${model_nameorcustom}:${key}`,val$jsonobj);
    }
    async hsetsetupdate(key,val$jsonobj,model_nameorcustom,ttl){
        await this.client.hset(`${model_nameorcustom}:${val$jsonobj}`,val$jsonobj);
    }
    async hsetget(key,model_nameorcustom,ttl){
        await this.client.hgetall(model_nameorcustom+":"+key);
    }
    async hsetmultipleget(key,model_name,required_key_arr){
        await this.client.hmget(model_nameorcustom+":"+key,...required_key_arr);
    }
    async hsetoneget(ey,model_nameorcustom,required_key_arr){
        await this.client.hmget(model_nameorcustom+":"+key,...required_key_arr);
    }


}
   #queryconstructor= class{
    constructor(client ,model_name,ttl){
        if (client ===undefined ||model_name===undefined){
            throw new Error("parameter in where constructor in not present");
        }
        this.operationget=[];
        this.operationset=[];
        this.client=client;
        this.model_name=model_name;
        this.ttl = ttl;



    }
    jsonttl(ttl){
        this.ttl=ttl;
    }
    jsonget(key,pathinput,model_name){
        this.operationget.push([key,pathinput]);
        return this;
    }
    jsonset(key,jsonobj,model_name){
        this.operationset.push([key, jsonobj]);
        return this;
    }
    jsonarrparser(result){
        let finalarr=[];
        for (let i=0;result[i]!=undefined;i++){
            finalarr.push(result[i][0]);

        }
        return finalarr;
    }

    async exec(){
        const luascript=`
       local operationset=cjson.decode(KEYS[1])
       local operationget=cjson.decode(KEYS[2])
       local ttl=KEYS[4]
       local model_name=KEYS[3]
       local res
       for i, name in ipairs(operationset) do
       redis.call("JSON.SET",model_name .. ":" .. name[1],"$",cjson.encode(name[2]))
       redis.call("EXPIRE",model_name .. ":" .. name[1],ttl)
       end
        local gets={ }
       for i, name in ipairs(operationget) do
        local path = "$"
        if name[2] ~= "" then
        path = "$." .. name[2]
        end
        gets[i-1]=cjson.decode(redis.call("JSON.GET",model_name .. ":" .. name[1],path) )
       end

       return cjson.encode(gets)

       `;

        const result= JSON.parse(await this.client.eval(luascript,4,JSON.stringify(this.operationset),JSON.stringify(this.operationget),this.model_name,this.ttl));

        this.operationget=[];
        this.operationset=[];
        return this.jsonarrparser(result);

    }
}
}

// redis.jsonSchemaIdx("Us",[{
//     key_name:"id",
//     tag_type:"NUMERIC",
//     sortable: true,
// }, {
//     key_name:"first_name",
//     tag_type:"TEXT"
// },{
//     key_name:"last_name",
//     tag_type:"TEXT"
// },{
//     key_name:"email",
//     tag_type:"TAG"
// },{
//     key_name:"gender",
//     tag_type:"TAG"
// },{
//     key_name:"age",
//     tag_type:"NUMERIC",
//     sortable:true
// }]);

